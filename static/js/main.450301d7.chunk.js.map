{"version":3,"sources":["Share/upload.png","ModalContent/ModalContent.tsx","ModalContent/clipboard.png","Download/saveToDrive.ts","Download/humanBytes.js","Download/download_file.png","serviceWorker.ts","index.tsx","Share/Share.tsx","App/App.tsx","Download/Download.tsx"],"names":["module","exports","UrlCopyComponent","url","ref","useRef","copyText","useCallback","current","select","setSelectionRange","document","execCommand","className","type","value","readOnly","onClick","src","clipboardIcon","alt","ModalContent","props","useState","uploadState","setUploadState","uuid","setUUID","useEffect","client","WebTorrent","on","error","console","seed","file","torrent","codedMagnet","Buffer","from","magnetURI","toString","text","maxLength","getUrl","window","location","href","renderAs","name","length","slice","onClose","saveToDrive","buffer","w","d","URL","createObjectURL","Blob","Uint8Array","tempLink","createElement","setAttribute","click","humanFileSize","bytes","si","thresh","Math","abs","units","u","toFixed","Boolean","hostname","match","ReactModal","setAppElement","ReactDOM","render","StrictMode","basename","process","App","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","message","Share","isOverlayHidden","hideOverlay","isModalShown","showModal","setFile","onDragStartEnd","ev","start","preventDefault","onDrop","files","dataTransfer","items","i","kind","f","getAsFile","push","promptFile","input","multiple","Promise","resolve","onchange","Array","fileDialog","ShareContent","onDragOver","onDragLeave","uploadIcon","draggable","isOpen","contentLabel","overlayClassName","closeTimeoutMS","DownloadContext","React","createContext","magnet","Provider","path","Download","params","useParams","context","useContext","speed","setSpeed","downloadState","setDownloadState","history","useHistory","fileID","replace","log","add","infoHash","interv","setInterval","downloadSpeed","clearInterval","forEach","getBuffer","err","buf","save","downloadImg","state","renderState"],"mappings":"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","file":"static/js/main.450301d7.chunk.js","sourcesContent":["module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACQAAAAkCAYAAADhAJiYAAAAVklEQVR4Ae3WgQYAIAAD0f54/w8KYoCgOLlxADzAxsM5Nx8n6GfQ/bnsMJi5CwfTwsG0cDAtHEwLB9PCwbRwMC0cTAsH00LCFHVrqJshSJAgQYLOc24BCDllHPtXdTgAAAAASUVORK5CYII=\"","import React, { useState, useEffect, useRef, useCallback } from 'react';\nimport QRCode from 'qrcode.react';\nimport WebTorrent from 'webtorrent';\n\nimport clipboardIcon from './clipboard.png';\n\nconst shortenString = (text: string, maxLength: number) => {\n  if (text.length <= maxLength) return text;\n\n  return `${text.slice(0, maxLength - 3)}...`;\n};\n\nfunction UrlCopyComponent({ url }: { url: string }) {\n  const ref = useRef<HTMLInputElement>(null);\n\n  const copyText = useCallback(() => {\n    ref.current?.select();\n    ref.current?.setSelectionRange(0, 99999);\n    document.execCommand('copy');\n    ref.current?.setSelectionRange(0, 0);\n  }, [ref]);\n\n  return (\n    <div className=\"url-copy\">\n      <input className=\"url-copy-input\" type=\"text\" value={url} ref={ref} readOnly />\n      <span className=\"url-copy-button\" onClick={() => copyText()}>\n        <img src={clipboardIcon} alt=\"Copy url to clipboard\" />\n      </span>\n    </div>\n  );\n}\n\nfunction ModalContent(props: { file: File; onClose: () => void }) {\n  const [uploadState, setUploadState] = useState<'loading' | 'uploading' | 'error'>('loading');\n  const [uuid, setUUID] = useState(null as null | string);\n\n  useEffect(() => {\n    const client = new WebTorrent();\n\n    client.on('error', (error) => {\n      setUploadState('error');\n      console.error(error);\n    });\n\n    client.seed(props.file, (torrent) => {\n      setUploadState('uploading');\n      const codedMagnet = Buffer.from(torrent.magnetURI).toString('base64');\n      setUUID(codedMagnet);\n    });\n  }, [props.file, setUUID]);\n\n  const getUrl = () => {\n    return `${window.location.href}download/${uuid != null ? uuid : ''}`;\n  };\n\n  return (\n    <div className=\"modal-root\">\n      <div className=\"modal-body\">\n        <div>You are sharing file. Do not close this modal.</div>\n        <div>\n          <QRCode className=\"qrcode\" renderAs=\"svg\" value={getUrl()} />\n        </div>\n        <div>{uploadState === 'uploading' ? shortenString(props.file.name, 30) : 'Loading file...'}</div>\n        <UrlCopyComponent url={uuid != null ? getUrl() : ''} />\n        <button className=\"button\" onClick={props.onClose}>\n          Close\n        </button>\n      </div>\n    </div>\n  );\n}\n\nexport default ModalContent;\n","module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACQAAAAkCAYAAADhAJiYAAAAwUlEQVR4Ae3OAQYCQRSH8bCAPUCAEMJiEUJYAoTQUTrAHKAjdIBFB+gQAcJiEcIihEEIrw8FsWa2xiS9Pz94eL7eh8tRokaFDYb4yjJYyAuLCaIuxQHSokaCYMuxwwXicEKBOSzEoYFBH15L0EA8rfFcCfF0RArnlpAOKgyQ4QzpYAHnDOTBtNz9uP+YvwrSoALmTUX4oHDTIA3SIA3SIA3SoMDTIA3SoBUkkhmcG+EaIaaC96bY4gZBaHuMofv93QGc9XVBb1MwIAAAAABJRU5ErkJggg==\"","const saveToDrive = (name: string, buffer: Buffer, w = window, d = document) => {\n  const url = w.URL.createObjectURL(new Blob([new Uint8Array(buffer, 0, buffer.length)]));\n  const tempLink = d.createElement('a');\n  tempLink.href = url;\n  tempLink.setAttribute('download', name);\n  tempLink.click();\n};\n\nexport default saveToDrive;\n","function humanFileSize(bytes, si = true) {\n  const thresh = si ? 1000 : 1024;\n  if (Math.abs(bytes) < thresh) {\n    return bytes + ' B';\n  }\n  const units = si\n    ? ['kB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB']\n    : ['KiB', 'MiB', 'GiB', 'TiB', 'PiB', 'EiB', 'ZiB', 'YiB'];\n  let u = -1;\n  do {\n    bytes /= thresh;\n    ++u;\n  } while (Math.abs(bytes) >= thresh && u < units.length - 1);\n  return bytes.toFixed(1) + ' ' + units[u];\n}\n\nexport default humanFileSize;\n","module.exports = __webpack_public_path__ + \"static/media/download_file.052d4597.png\";","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './style/index.scss';\nimport App from './App/App';\nimport ReactModal from 'react-modal';\nimport * as serviceWorker from './serviceWorker';\nimport { HashRouter as Router } from 'react-router-dom';\n\nReactModal.setAppElement('#root');\n\nReactDOM.render(\n  <React.StrictMode>\n    <Router basename={process.env.PUBLIC_URL}>\n      <App />\n    </Router>\n  </React.StrictMode>,\n  document.getElementById('root'),\n);\n\nserviceWorker.unregister();\n","import React, { useState, useCallback } from 'react';\nimport Modal from 'react-modal';\n\n// import addFile from './add_file.png';\nimport uploadIcon from './upload.png';\nimport ModalContent from '../ModalContent/ModalContent';\n\nfunction fileDialog(): Promise<File[] | null> {\n  const input = document.createElement('input');\n  input.type = 'file';\n  input.multiple = false;\n  // input.accept = contentType;\n  return new Promise(function (resolve) {\n    input.onchange = function () {\n      if (input.files == null) return resolve();\n\n      const files = Array.from(input.files);\n      return resolve(files);\n      // resolve(files[0]);\n    };\n    input.click();\n  });\n}\n\nfunction Share() {\n  const [isOverlayHidden, hideOverlay] = useState(true);\n  const [isModalShown, showModal] = useState(false);\n  const [file, setFile] = useState(null as File | null);\n\n  const onDragStartEnd = (ev: React.DragEvent<HTMLDivElement>, start: boolean) => {\n    ev.preventDefault();\n    hideOverlay(!start);\n  };\n\n  const onDrop = useCallback(\n    (ev: React.DragEvent<HTMLDivElement>) => {\n      ev.preventDefault();\n      hideOverlay(true);\n      showModal(true);\n\n      let files: File[] | FileList;\n      if (ev.dataTransfer.items) {\n        files = [];\n        for (let i = 0; i < ev.dataTransfer.items.length; i++) {\n          if (ev.dataTransfer.items[i].kind === 'file') {\n            const f: File | null = ev.dataTransfer.items[i].getAsFile();\n            if (f) {\n              files.push(f);\n            }\n          }\n        }\n      } else {\n        files = ev.dataTransfer.files;\n      }\n      if (files[0]) {\n        setFile(files[0]);\n      }\n    },\n    [hideOverlay],\n  );\n\n  const promptFile = useCallback(() => {\n    fileDialog().then((file) => {\n      if (file == null) return;\n      hideOverlay(true);\n      showModal(true);\n      setFile(file[0]);\n    });\n  }, [setFile]);\n\n  const ShareContent = useCallback(\n    ({ isModalShown }: { isModalShown: boolean }) => {\n      if (!isModalShown) {\n        return (\n          <div className=\"share-content\">\n            <div\n              className=\"file-drop-area\"\n              onDrop={onDrop}\n              onDragOver={(ev) => onDragStartEnd(ev, true)}\n              onDragLeave={(ev) => onDragStartEnd(ev, false)}\n              onClick={() => promptFile()}\n            >\n              <div>Drop a file to upload</div>\n              <img src={uploadIcon} alt=\"Upload file\" draggable={false} />\n              <div>or click to browse</div>\n            </div>\n          </div>\n        );\n      }\n      return null;\n    },\n    [onDrop, promptFile],\n  );\n\n  return (\n    <div className=\"share-root\">\n      <div className={`${isOverlayHidden ? 'hide-overlay' : 'show-overlay'}`} />\n      <Modal\n        isOpen={isModalShown && file != null}\n        contentLabel=\"File modal\"\n        className=\"modal\"\n        overlayClassName=\"modal-overlay\"\n        closeTimeoutMS={200}\n      >\n        <ModalContent file={file as File} onClose={() => showModal(false)} />\n      </Modal>\n\n      <ShareContent isModalShown={isModalShown} />\n    </div>\n  );\n}\n\nexport default Share;\n","import React from 'react';\nimport { Switch, Route } from 'react-router-dom';\nimport Share from '../Share/Share';\nimport Download from '../Download/Download';\n\nexport const DownloadContext = React.createContext<{ magnet: string | null }>({ magnet: null });\n\nfunction App() {\n  return (\n    <Switch>\n      <DownloadContext.Provider value={{ magnet: null }}>\n        <Route path=\"/download/:fileID\">\n          <Download />\n        </Route>\n        <Route path=\"/download/\">\n          <Download />\n        </Route>\n        <Route path=\"/\">\n          <Share />\n        </Route>\n      </DownloadContext.Provider>\n    </Switch>\n  );\n}\n\nexport default App;\n","import React, { useEffect, useState, useContext } from 'react';\nimport { useParams, useHistory } from 'react-router-dom';\nimport WebTorrent from 'webtorrent';\nimport save from './saveToDrive';\nimport humanFileSize from './humanBytes';\nimport downloadImg from './download_file.png';\nimport { DownloadContext } from '../App/App';\n\nfunction Download() {\n  const params = useParams<{ fileID?: string }>();\n  const context = useContext(DownloadContext);\n  const [speed, setSpeed] = useState(0);\n  const [downloadState, setDownloadState] = useState('waiting' as 'waiting' | 'downloading' | 'downloaded');\n  const history = useHistory();\n\n  useEffect(() => {\n    if (params.fileID != null) {\n      context.magnet = params.fileID;\n      history.replace('/download/');\n    }\n  }, [params, context, history]);\n\n  useEffect(() => {\n    if (context.magnet == null && params.fileID == null) {\n      history.replace('/');\n    }\n  }, [params, context, history]);\n\n  useEffect(() => {\n    if (context.magnet == null || params.fileID != null) {\n      return;\n    }\n\n    const fileID = context.magnet;\n    setDownloadState('downloading');\n    const client = new WebTorrent();\n    const magnet = Buffer.from(fileID, 'base64').toString('utf-8');\n    console.log('Look for: ', magnet);\n    client.add(magnet, (torrent) => {\n      // Got torrent metadata!\n      console.log('Client is downloading:', torrent.infoHash);\n\n      const intervalUpdateTime = 1000;\n      const interv = setInterval(() => {\n        setSpeed(torrent.downloadSpeed);\n      }, intervalUpdateTime);\n\n      torrent.on('done', () => {\n        clearInterval(interv);\n        setDownloadState('downloaded');\n        torrent.files.forEach(function (file) {\n          console.log(file.name);\n          file.getBuffer((err, buf) => {\n            if (err == null && buf != null) {\n              save(file.name, buf);\n            }\n          });\n        });\n      });\n    });\n  }, [context, params]);\n\n  const renderState = (state: typeof downloadState) => {\n    switch (state) {\n      case 'waiting':\n        return (\n          <>\n            <div>Waiting for server...</div>\n          </>\n        );\n\n      case 'downloading':\n        return (\n          <>\n            <div>You are downloading.</div>\n            <div>{humanFileSize(speed)}/s</div>\n          </>\n        );\n      case 'downloaded':\n        return (\n          <>\n            <div>Downloading finished.</div>\n          </>\n        );\n    }\n  };\n  return (\n    <div className=\"download-root\">\n      <div className=\"download-border\">\n        <div className=\"download-body\">\n          <img src={downloadImg} alt=\"Download file\" draggable={false} />\n          {renderState(downloadState)}\n        </div>\n      </div>\n    </div>\n  );\n}\n\nexport default Download;\n"],"sourceRoot":""}